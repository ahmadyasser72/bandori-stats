---
import { db } from "@bandori-stats/database";
import { redis } from "@bandori-stats/database/redis";

import dayjs from "~/lib/date";
import { formatNumber, sum } from "~/lib/math";
import { parseSearchParams } from "./_params";

export const partial = true;

const { date, page, rank_by, sort_latest, search_username } = parseSearchParams(
	Astro.url.searchParams,
);

{
	const replaceUrl = new URL("/leaderboard", Astro.url);
	replaceUrl.searchParams.set("sort_latest", String(sort_latest));
	if (!rank_by.default) {
		rank_by.items.forEach((it) =>
			replaceUrl.searchParams.append("rank_by", it),
		);
	}
	Astro.response.headers.set("hx-replace-url", replaceUrl.href);
}

const leaderboard = await (async () => {
	const p = redis.pipeline();
	for (const column of rank_by.items) {
		const key = `leaderboard:${date}:${column}`;
		p.zrange(key, 0, "+inf", { byScore: true, withScores: true });
	}

	const entries = await p.exec<number[][]>();
	return Object.fromEntries(
		rank_by.items.map((column, idx) => [
			column,
			entries[idx].reverse().filter((_, idx) => idx % 2 === 0),
		]),
	);
})();

const getRows = async () =>
	db.query.accounts.findMany({
		columns: { id: true, username: true, nickname: true },
		with: {
			snapshots: {
				limit: 1,
				columns: { stats: true, snapshotDate: true },
				where: { snapshotDate: { lte: date } },
				orderBy: { snapshotDate: "desc" },
			},
		},
	});

const rows = await (async () => {
	type Rows = Awaited<ReturnType<typeof getRows>>;
	const cacheKey = `queryw:${date}`;

	const rows = await redis
		.get<Rows>(cacheKey)
		.then((cached) => cached ?? getRows());
	await redis.set(cacheKey, rows, {
		ex: dayjs().endOf("hours").diff(dayjs(), "seconds"),
	});

	const results = rows
		.filter(({ snapshots }) => snapshots.length > 0)
		.map(({ snapshots: [{ snapshotDate, stats }], ...account }) => {
			const scores =
				sum(
					rank_by.items.map((column) => {
						if (!stats[column]) return 0;

						const rankings = leaderboard[column];
						return 1 - rankings.indexOf(stats[column]) / (rankings.length - 1);
					}),
				) / rank_by.items.length;
			const hasNickname =
				account.nickname && account.nickname !== account.username;

			return { ...account, snapshotDate, stats, scores, hasNickname };
		})
		.sort((a, b) => b.scores - a.scores);

	const resultsWithRank = results.reduce<
		((typeof results)[number] & { top: number })[]
	>((acc, next, idx) => {
		const lastResult = acc.at(-1);
		const top = lastResult?.scores === next.scores ? lastResult.top : idx + 1;

		acc.push({ ...next, top });
		return acc;
	}, []);

	const filtered = resultsWithRank.filter(
		({ username, nickname }) =>
			!search_username ||
			username.toLowerCase().includes(search_username) ||
			nickname?.toLowerCase().includes(search_username),
	);

	return sort_latest
		? filtered.sort((a, b) => dayjs(b.snapshotDate).diff(dayjs(a.snapshotDate)))
		: filtered;
})();

const pageSize = 20;
const offset = (page - 1) * pageSize;
const pageRows = rows.slice(offset, offset + pageSize);

const nextPageHtmxProps = (() => {
	if (offset + pageSize > rows.length) return {};

	const nextPageUrl = new URL(Astro.url);
	nextPageUrl.search = "";
	nextPageUrl.searchParams.set("page", (page + 1).toString());
	return {
		"hx-get": nextPageUrl.href,
		"hx-target": "closest tbody",
		"hx-swap": "beforeend",
		"hx-trigger": "intersect once",
	};
})();
---

{
	pageRows.map(
		(
			{ id, username, nickname, hasNickname, snapshotDate, stats, top },
			idx,
		) => (
			// trigger infinite loader on the 5th last row
			<tr {...(idx === pageSize - 5 ? nextPageHtmxProps : {})} class="group">
				<th>#{top.toString().padStart(3, "0")}</th>

				<td class="bg-base-100/20 sticky left-0 z-10 pl-0">
					<span
						class="flex items-center font-medium"
						style={page === 1 && `view-transition-name: account-${id};`}
					>
						<div class="flex flex-col -space-y-0.5">
							{hasNickname && (
								<div>
									<span class="group-even:bg-base-200 group-odd:bg-base-100 line-clamp-1 max-w-36 overflow-clip px-2 break-all text-ellipsis">
										{nickname}
									</span>
								</div>
							)}
							<div>
								<span
									class:list={[
										"group-even:bg-base-200 group-odd:bg-base-100 line-clamp-1 max-w-36 overflow-clip px-2 text-ellipsis",
										hasNickname && "text-base-content/60",
									]}
								>
									@{username}
								</span>
							</div>
						</div>
					</span>
				</td>
				<td hx-disinherit="hx-indicator">
					<button
						hx-get={`/leaderboard/stats/${id}_${date}`}
						hx-target="body"
						hx-swap="beforeend"
						hx-disabled-elt=".stats-history"
						class="stats-history btn btn-primary btn-sm btn-circle"
					>
						<iconify-icon
							icon="lucide:history"
							width="none"
							class="htmx-indicator-replace size-4"
						/>
						<iconify-icon
							icon="svg-spinners:90-ring-with-bg"
							width="none"
							class="htmx-indicator size-4"
						/>
					</button>
				</td>

				<td>{snapshotDate}</td>

				{Object.entries(stats).map(([key, value]) => (
					<td
						class:list={[
							(!rank_by.items.includes(key) && "line-through opacity-60") ||
								(value === null && "font-medium opacity-40"),
						]}
					>
						{value ? formatNumber(value) : "Private"}
					</td>
				))}
			</tr>
		),
	)
}
