---
import { db } from "@bandori-stats/database";
import { SELECT_STAT_COLUMNS } from "@bandori-stats/database/constants";
import { redis } from "@bandori-stats/database/redis";
import dayjs from "dayjs";

import { formatNumber, sum } from "~/lib/math";
import { parseSearchParams } from "./_params";

export const partial = true;

const { date, page, rank_by, sort_latest, search_username } = parseSearchParams(
	Astro.url.searchParams,
);

{
	const replaceUrl = new URL("/leaderboard", Astro.url);
	replaceUrl.searchParams.set("sort_latest", String(sort_latest));
	if (!rank_by.default) {
		rank_by.items.forEach((it) =>
			replaceUrl.searchParams.append("rank_by", it),
		);
	}
	Astro.response.headers.set("hx-replace-url", replaceUrl.href);
}

const leaderboard = await (async () => {
	const p = redis.pipeline();
	for (const column of rank_by.items) {
		const key = `leaderboard:${date}:${column}`;
		p.zrange(key, 0, "+inf", { byScore: true, withScores: true });
	}

	const entries = await p.exec<number[][]>();
	return Object.fromEntries(
		rank_by.items.map((column, idx) => [
			column,
			entries[idx].reverse().filter((_, idx) => idx % 2 === 0),
		]),
	);
})();

const getRows = async () =>
	db.query.accounts.findMany({
		columns: { id: true, username: true },
		with: {
			snapshots: {
				limit: 1,
				columns: { ...SELECT_STAT_COLUMNS, snapshotDate: true },
				orderBy: (t, { desc }) => desc(t.snapshotDate),
				where: (t, { lte }) => lte(t.snapshotDate, date),
			},
		},
	});

const rows = await (async () => {
	type Rows = Awaited<ReturnType<typeof getRows>>;
	const cacheKey = `query:${date}`;

	const rows = await redis
		.get<Rows>(cacheKey)
		.then((cached) => cached ?? getRows());
	await redis.set(cacheKey, rows, {
		ex: dayjs().endOf("hours").diff(dayjs(), "seconds"),
	});

	const results = rows
		.filter(({ snapshots }) => snapshots.length > 0)
		.map(({ snapshots: [{ snapshotDate, ...stats }], ...account }) => {
			const scores =
				sum(
					rank_by.items.map((column) => {
						if (!stats[column]) return 0;

						const rankings = leaderboard[column];
						return 1 - rankings.indexOf(stats[column]) / (rankings.length - 1);
					}),
				) / rank_by.items.length;

			return { ...account, snapshotDate, stats, scores };
		})
		.sort((a, b) => b.scores - a.scores);

	const resultsWithRank = results.reduce<
		((typeof results)[number] & { top: number })[]
	>((acc, next, idx) => {
		const lastResult = acc.at(-1);
		const top = lastResult?.scores === next.scores ? lastResult.top : idx + 1;

		acc.push({ ...next, top });
		return acc;
	}, []);

	const filtered = resultsWithRank.filter(
		({ username }) =>
			!search_username || username.toLowerCase().includes(search_username),
	);

	return sort_latest
		? filtered.sort((a, b) => dayjs(b.snapshotDate).diff(dayjs(a.snapshotDate)))
		: filtered;
})();

const pageSize = 25;
const offset = (page - 1) * pageSize;
const pageRows = rows.slice(offset, offset + pageSize);

const nextPageHtmxProps = (() => {
	if (offset + pageSize > rows.length) return {};

	const nextPageUrl = new URL(Astro.url);
	nextPageUrl.search = "";
	nextPageUrl.searchParams.set("page", (page + 1).toString());
	return {
		"hx-get": nextPageUrl.href,
		"hx-target": "closest tbody",
		"hx-swap": "beforeend",
		"hx-trigger": "intersect once",
	};
})();
---

{
	pageRows.map(({ id, username, snapshotDate, stats, top }, idx) => (
		// trigger infinite loader on the 5th last row
		<tr {...(idx === pageSize - 5 ? nextPageHtmxProps : {})}>
			<th>#{top.toString().padStart(3, "0")}</th>

			<th
				hx-disinherit="hx-indicator"
				class="bg-base-100/20 sticky left-0 z-10 pl-0"
			>
				<span
					hx-get={`/leaderboard/stats/${id}_${date}`}
					hx-target="body"
					hx-swap="beforeend"
					class="bg-base-100 link max-w-36 overflow-clip pr-2 pl-4 text-ellipsis"
					style={idx < 30 && `view-transition-name: account-${id};`}
				>
					{username}

					<iconify-icon
						inline
						icon="svg-spinners:3-dots-scale"
						width="none"
						class="htmx-indicator ml-2 size-3"
					/>
				</span>
			</th>

			<td>{snapshotDate}</td>

			{Object.entries(stats).map(([key, value]) => (
				<td
					class:list={[
						(value === null && "font-medium opacity-40") ||
							(!rank_by.items.includes(key) && "line-through opacity-60"),
					]}
				>
					{value ? formatNumber(value) : "Private"}
				</td>
			))}
		</tr>
	))
}
