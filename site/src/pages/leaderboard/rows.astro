---
import { STAT_NAMES } from "@bandori-stats/bestdori/constants";
import { db } from "@bandori-stats/database";
import { redis } from "@bandori-stats/database/redis";

import dayjs from "~/lib/date";
import { formatNumber, sum } from "~/lib/math";
import { parseSearchParams } from "./_params";

export const partial = true;

const { date, page, rank_by, sort_latest, search_username, favorite } =
	parseSearchParams(Astro.url.searchParams);

{
	const replaceUrl = new URL("/leaderboard", Astro.url);

	if (sort_latest)
		replaceUrl.searchParams.set("sort_latest", String(sort_latest));

	if (!rank_by.default) {
		rank_by.items.forEach((it) =>
			replaceUrl.searchParams.append("rank_by", it),
		);
	}

	favorite
		.values()
		.forEach((it) => replaceUrl.searchParams.append("favorite", it));

	Astro.response.headers.set("hx-replace-url", replaceUrl.href);
}

const leaderboard = await (async () => {
	const p = redis.pipeline();
	for (const name of rank_by.items) {
		const key = `leaderboard:${date}:${name}`;
		p.zrange(key, 0, "+inf", { byScore: true, withScores: true });
	}

	const entries = await p.exec<number[][]>();
	return Object.fromEntries(
		rank_by.items.map((name, idx) => [
			name,
			entries[idx].reverse().filter((_, idx) => idx % 2 === 0),
		]),
	);
})();

const getRows = async () =>
	db.query.accounts.findMany({
		columns: { id: true, username: true, nickname: true },
		with: {
			snapshots: {
				limit: 1,
				columns: { stats: true, snapshotDate: true },
				where: { snapshotDate: { lte: date } },
				orderBy: { snapshotDate: "desc" },
			},
		},
	});

const rows = await (async () => {
	type Rows = Awaited<ReturnType<typeof getRows>>;
	const cacheKey = `query:${date}`;

	const rows = await redis
		.get<Rows>(cacheKey)
		.then((cached) => cached ?? getRows());
	await redis.set(cacheKey, rows, {
		ex: dayjs().endOf("hours").diff(dayjs(), "seconds"),
	});

	const leaderboardIndex = Object.fromEntries(
		rank_by.items.map((name) => [
			name,
			new Map(leaderboard[name].map((v, i) => [v, i])),
		]),
	);

	const results = rows
		.filter(({ snapshots }) => snapshots.length > 0)
		.map(({ snapshots: [{ snapshotDate, stats }], ...account }) => {
			const scores =
				sum(
					rank_by.items.map((name) => {
						const value = stats[name];
						if (value == null) return 0;

						const rankings = leaderboard[name];
						const idx = leaderboardIndex[name].get(value);
						if (idx == null) return 0;

						return 1 - idx / (rankings.length - 1);
					}),
				) / rank_by.items.length;
			const hasNickname =
				account.nickname && account.nickname !== account.username;

			return { ...account, snapshotDate, stats, scores, hasNickname };
		})
		.sort((a, b) => b.scores - a.scores);

	const resultsWithRank = results.reduce<
		((typeof results)[number] & { top: number })[]
	>((acc, next, idx) => {
		const lastResult = acc.at(-1);
		const top = lastResult?.scores === next.scores ? lastResult.top : idx + 1;

		acc.push({ ...next, top });
		return acc;
	}, []);

	const filtered = resultsWithRank.filter(
		({ username, nickname }) =>
			!search_username ||
			username.toLowerCase().includes(search_username) ||
			nickname?.toLowerCase().includes(search_username),
	);

	const sorted = sort_latest
		? filtered.sort((a, b) => b.snapshotDate.localeCompare(a.snapshotDate))
		: filtered;

	for (let idx = sorted.length - 1; idx > favorite.size - 1; idx -= 1) {
		const { username } = sorted[idx];
		if (favorite.has(username)) sorted.unshift(sorted.splice(idx, 1)[0]);
	}

	return sorted;
})();

const pageSize = 20;
const offset = (page - 1) * pageSize;
const pageRows = rows.slice(offset, offset + pageSize);

const nextPageHtmxProps = (() => {
	if (offset + pageSize > rows.length) return {};

	return {
		"hx-get": "/leaderboard/rows",
		"hx-vals": JSON.stringify({ page: page + 1 }),
		"hx-target": "closest tbody",
		"hx-swap": "beforeend",
		"hx-trigger": "intersect once",
	};
})();
---

{
	pageRows.map(
		(
			{ id, username, nickname, hasNickname, snapshotDate, stats, top },
			idx,
		) => (
			// trigger infinite loader on the 5th last row
			<tr
				{...(idx === pageSize - 5 ? nextPageHtmxProps : {})}
				class="group text-center"
			>
				<th>#{top.toString().padStart(3, "0")}</th>

				<td class="pointer-events-none sticky left-0 z-10 pl-0 text-start">
					<span
						class="pointer-events-auto flex items-center font-medium"
						style={page === 1 && `view-transition-name: account-${id};`}
					>
						<div class="flex flex-col -space-y-0.5">
							{hasNickname && (
								<div>
									<span class="group-even:bg-base-200 group-odd:bg-base-100 line-clamp-1 max-w-36 overflow-clip px-2 break-all text-ellipsis">
										{nickname}
									</span>
								</div>
							)}
							<div>
								<span
									class:list={[
										"group-even:bg-base-200 group-odd:bg-base-100 line-clamp-1 max-w-36 overflow-clip px-2 text-ellipsis",
										hasNickname && "text-base-content/60",
									]}
								>
									@{username}
								</span>
							</div>
						</div>
					</span>
				</td>

				<td hx-disinherit="hx-indicator">
					<div class="flex items-center gap-1">
						<input
							hx-get="/leaderboard/rows"
							hx-target="closest tbody"
							hx-indicator="#app-loader"
							hx-swap="innerHTML transition:true"
							type="checkbox"
							name="favorite"
							value={username}
							checked={favorite.has(username)}
							class="mask mask-star dark:bg-neutral bg-primary checked:bg-primary-content checked:dark:bg-primary size-7 cursor-pointer appearance-none"
							aria-label={`Favorite ${nickname ?? username}`}
						/>

						<button
							hx-get={`/leaderboard/stats/${id}_${date}`}
							hx-target="body"
							hx-swap="beforeend"
							hx-disabled-elt=".stats-history"
							class="stats-history btn btn-primary btn-sm btn-circle"
						>
							<iconify-icon
								icon="lucide:history"
								width="none"
								class="htmx-indicator-replace size-4"
							/>
							<iconify-icon
								icon="svg-spinners:90-ring-with-bg"
								width="none"
								class="htmx-indicator size-4"
							/>
						</button>
					</div>
				</td>

				<td>{snapshotDate}</td>

				{STAT_NAMES.map((key) => ({ key, value: stats[key] })).map(
					({ key, value }) => (
						<td
							class:list={[
								(!rank_by.items.includes(key) && "line-through opacity-60") ||
									(value === null && "font-medium opacity-40"),
							]}
						>
							{value ? formatNumber(value) : "Private"}
						</td>
					),
				)}
			</tr>
		),
	)
}
