---
import { db, sql } from "@bandori-stats/database";
import {
	SELECT_STAT_COLUMNS,
	STAT_COLUMNS,
} from "@bandori-stats/database/constants";
import { zScore } from "@bandori-stats/database/schema";
import dayjs from "dayjs";

import { formatNumber, sum } from "~/lib/math";
import { parseSearchParams } from "./_params";

export const partial = true;

const { date, page, rank_by, sort_latest, search_username } = parseSearchParams(
	Astro.url.searchParams,
);

{
	const replaceUrl = new URL("/leaderboard", Astro.url);
	replaceUrl.searchParams.set("sort_latest", String(sort_latest));
	rank_by.forEach((it) => replaceUrl.searchParams.append("rank_by", it));
	Astro.response.headers.set("hx-replace-url", replaceUrl.href);

	if (import.meta.env.PROD)
		Astro.response.headers.set(
			"cache-control",
			"max-age=300, stale-while-revalidate=60",
		);
}

const stats = (await db.query.zScore.findFirst({
	columns: {
		date: true,
		...Object.fromEntries(
			STAT_COLUMNS.map((column) => [`mean_${column}`, true]),
		),
	},
	where: (t, { lte }) => lte(t.date, date),
	orderBy: (t, { desc }) => desc(t.date),
	extras: Object.fromEntries(
		STAT_COLUMNS.map((column) => [
			`stddev_${column}` as const,
			sql<number>`
				CASE
					WHEN ${zScore[`n_${column}`]} > 1
					THEN sqrt(${zScore[`m2_${column}`]} / (${zScore[`n_${column}`]} - 1))
					ELSE 0
				END
			`.as(`stddev_${column}`),
		]),
	),
}))!;

const rows = await db.query.accounts
	.findMany({
		columns: { id: true, username: true },
		with: {
			snapshots: {
				limit: 1,
				columns: { ...SELECT_STAT_COLUMNS, snapshotDate: true },
				orderBy: (t, { desc }) => desc(t.snapshotDate),
				where: (t, { lte }) => lte(t.snapshotDate, stats.date),
			},
		},
	})
	.then((entries) =>
		entries
			.filter(({ snapshots }) => snapshots.length > 0)
			.map(({ id, username, snapshots: [{ snapshotDate, ...snapshot }] }) => ({
				id,
				username,
				lastUpdated: snapshotDate,
				stats: snapshot,
				scores: sum(
					STAT_COLUMNS.filter((column) => rank_by.includes(column)).map(
						(column) =>
							((snapshot[column] ?? 0) - stats[`mean_${column}`]) /
							stats[`stddev_${column}`],
					),
				),
			}))
			.sort((a, b) => b.scores - a.scores)
			.map((it, idx) => ({ ...it, top: idx + 1 }))
			.filter(
				({ username }) =>
					!search_username || username.toLowerCase().includes(search_username),
			),
	);

if (sort_latest)
	rows.sort((a, b) => dayjs(b.lastUpdated).diff(dayjs(a.lastUpdated)));

const pageSize = 50;
const offset = (page - 1) * pageSize;
const pageRows = rows.slice(offset, offset + pageSize);

const nextPageUrl = new URL(Astro.url);
nextPageUrl.searchParams.set("page", (page + 1).toString());
const nextPageHtmxProps = {
	"hx-get": nextPageUrl.href,
	"hx-swap": "afterend",
	"hx-trigger": "intersect once",
};
---

{
	pageRows.map(({ id, username, lastUpdated, stats, top }, idx) => (
		<tr {...(idx === pageSize - 1 ? nextPageHtmxProps : {})}>
			<th>#{top.toString().padStart(3, "0")}</th>

			<th class="bg-base-100/20 sticky left-0 z-10 pl-0">
				<p class="inline-flex">
					<span
						hx-get={`/leaderboard/stats/${id}_${date}`}
						hx-target="body"
						hx-swap="beforeend"
						hx-indicator="next iconify-icon"
						class="bg-base-100 link max-w-36 overflow-clip pr-2 pl-4 text-ellipsis"
						style={idx < 30 && `view-transition-name: account-${id};`}
					>
						{username}
					</span>

					<iconify-icon
						icon="svg-spinners:3-dots-scale"
						width="16"
						class="htmx-indicator"
					/>
				</p>
			</th>

			<td>{lastUpdated}</td>

			{Object.entries(stats).map(([key, value]) => (
				<td
					class:list={[
						(value === null && "font-medium opacity-40") ||
							(!rank_by.includes(key) && "line-through opacity-60"),
					]}
				>
					{value ? formatNumber(value) : "Private"}
				</td>
			))}
		</tr>
	))
}
