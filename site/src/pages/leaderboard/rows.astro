---
import { STAT_NAMES } from "@bandori-stats/bestdori/constants";
import { db } from "@bandori-stats/database";
import { redis } from "@bandori-stats/database/redis";

import UsernameColumn from "~/lib/components/username-column.astro";
import { displayValue, mean } from "~/lib/math";
import { paginate } from "~/lib/paginate";
import { parseSearchParams } from "./_params";

export const partial = true;

const { date, rank_by, sort_latest, search_username, favorite } =
	parseSearchParams(Astro.url.searchParams);

{
	const replaceUrl = new URL("/leaderboard", Astro.url);

	if (sort_latest)
		replaceUrl.searchParams.set("sort_latest", String(sort_latest));

	if (!rank_by.default) {
		rank_by.items.forEach((it) =>
			replaceUrl.searchParams.append("rank_by", it),
		);
	}

	favorite
		.values()
		.forEach((it) => replaceUrl.searchParams.append("favorite", it));

	Astro.response.headers.set("hx-replace-url", replaceUrl.href);
}

const leaderboardIndex = await (async () => {
	const p = redis.pipeline();
	for (const name of rank_by.items) {
		const key = `leaderboard:${date}:${name}`;
		p.zrange(key, 0, "+inf", { byScore: true, withScores: true });
	}

	const entries = await p.exec<number[][]>();
	return new Map(
		rank_by.items.map((name, idx) => [
			name,
			new Map(
				entries[idx]
					.reverse()
					.filter((_, idx) => idx % 2 === 0)
					.map((value, idx) => [value, idx]),
			),
		]),
	);
})();

const rows = await (async () => {
	const accounts = await db.query.accounts.findMany({
		columns: { id: true, username: true, nickname: true },
		with: {
			snapshots: {
				limit: 1,
				columns: { stats: true, snapshotDate: true },
				where: { snapshotDate: { lte: date } },
				orderBy: { snapshotDate: "desc" },
			},
		},
	});

	const results = accounts
		.filter(({ snapshots }) => snapshots.length > 0)
		.map(({ snapshots: [{ snapshotDate, stats }], ...account }) => {
			const scores = mean(
				rank_by.items.map((name) => {
					const value = stats[name];
					if (value === null) return 0;

					const leaderboard = leaderboardIndex.get(name)!;
					const rank = leaderboard.get(value);
					if (rank === undefined) return 0;

					return 1 - rank / (leaderboard.size - 1);
				}),
			);

			return { ...account, snapshotDate, stats, scores };
		})
		.sort((a, b) => b.scores - a.scores);

	const resultsWithRank = results.reduce<
		((typeof results)[number] & { top: number })[]
	>((acc, next, idx) => {
		const lastResult = acc.at(-1);
		const top = lastResult?.scores === next.scores ? lastResult.top : idx + 1;

		acc.push({ ...next, top });
		return acc;
	}, []);

	const filtered = search_username
		? resultsWithRank.filter(
				({ username, nickname }) =>
					username.toLowerCase().includes(search_username) ||
					nickname?.toLowerCase().includes(search_username),
			)
		: resultsWithRank;

	const sorted = sort_latest
		? filtered.sort((a, b) => b.snapshotDate.localeCompare(a.snapshotDate))
		: filtered;

	if (favorite.size === 0) return sorted;

	const favs = [] as typeof sorted;
	const rest = [] as typeof sorted;
	for (const account of sorted) {
		(favorite.has(account.username) ? favs : rest).push(account);
	}

	return [...favs, ...rest];
})();

const page = paginate({
	items: rows,
	context: Astro,
	size: 20,
	extraProps: {
		"hx-target": "closest tbody",
		"hx-swap": "beforeend",
	},
});
---

{
	page.items.map(
		({ id, username, nickname, snapshotDate, stats, top }, idx) => (
			<tr
				{...(page.isLastElement(idx) && page.props)}
				class="group text-center"
			>
				<th>#{top.toString().padStart(3, "0")}</th>

				<UsernameColumn
					{id}
					{username}
					{nickname}
					viewTransition={page.current === 1}
				/>

				<td hx-disinherit="hx-indicator">
					<div class="flex items-center gap-1">
						<input
							hx-get="/leaderboard/rows"
							hx-target="closest tbody"
							hx-indicator="#app-loader"
							hx-swap="innerHTML transition:true"
							type="checkbox"
							name="favorite"
							value={username}
							checked={favorite.has(username)}
							class="mask mask-star dark:bg-neutral bg-primary checked:bg-primary-content checked:dark:bg-primary size-7 cursor-pointer appearance-none"
							aria-label={`Favorite ${nickname ?? username}`}
						/>

						<button
							hx-get={`/fragments/stats-history/${id}`}
							hx-target="body"
							hx-swap="beforeend"
							hx-disabled-elt=".stats-history"
							class="stats-history btn btn-primary btn-sm btn-circle"
						>
							<iconify-icon
								icon="lucide:history"
								width="none"
								class="htmx-indicator-replace size-4"
							/>
							<iconify-icon
								icon="svg-spinners:90-ring-with-bg"
								width="none"
								class="htmx-indicator size-4"
							/>
						</button>
					</div>
				</td>

				<td>{snapshotDate}</td>

				{STAT_NAMES.map((key) => ({ key, value: stats[key] })).map(
					({ key, value }) => (
						<td
							class:list={[
								(!rank_by.items.includes(key) && "line-through opacity-60") ||
									(!value && "font-medium opacity-40"),
							]}
						>
							{displayValue(value)}
						</td>
					),
				)}

				<td class:list={[!stats.titles && "font-medium opacity-40"]}>
					{displayValue(stats.titles?.length ?? null)}
				</td>
			</tr>
		),
	)
}
